// Semi-working design


#include <Encoder.h> // The encoder library comes in handy for this project


// Define some PINs for the encoder
#define ENCODER_PIN_A 2
#define ENCODER_PIN_B 5


// Define some PINs for the motor
#define PWM_OUTPUT_PIN 9
#define PI_CONSTANT 3.1415926536
// Define some constants for the PID Controller

#define PWM_BOUND 255

// Encoder variables
float motorPos = 0;
float angularPos = 0;
int N = 3200; //Counts per revolution
// PWM variables
int pwmSpeed = 0;
//float desiredPosition = 3.1415926536;
float desiredPosition = 3.1415926536;
float currentPosition = 0;
float error = 0;
float samplingTime = 0;
float storedTime = 0;
float currentTime;
float integrator = 0;
float storedIntegrator = 0;
int controlSignal = 0;

 // Constants obtained from MATLAB simulations
//const float Kp = 0.2274788;
//const float Ki = 0.0517371;

const float Kp = 0.2274788;
const float Ki = 0.0517371;

// Setup encoder - pins 2 (interrupt) and 5 (no interrupt)
Encoder motorEnc(ENCODER_PIN_A, ENCODER_PIN_B);

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  pinMode(4, OUTPUT);
  digitalWrite(4, HIGH);
  pinMode(7, OUTPUT);
  pinMode(8, OUTPUT);
  pinMode(PWM_OUTPUT_PIN, OUTPUT);
  pinMode(10, OUTPUT);
  pinMode(12, INPUT);
}

void loop() {
  // Read position
  motorPos = motorEnc.read();
  //Find current angular position
  angularPos = 2*PI*(double)motorPos/(double)N;

   //Serial.println(angularPos);
  //Mechanism to reset position to zero - https://www.pjrc.com/teensy/td_libs_Encoder.html#optimize
  //Looks for anything in the serial monitor, if there is something, write zero to encoder
  if (Serial.available()) {
    Serial.read();
    Serial.println("Reset position to zero");
    motorEnc.write(0);
  }
  PIDController();
}


void PIDController(){

  currentPosition = angularPos;
  currentTime = millis();
  error = desiredPosition - currentPosition;
  
  samplingTime = currentTime - storedTime;
  integrator = storedIntegrator + error * (samplingTime);
  controlSignal = Kp * error + Ki * integrator;


  if (abs(controlSignal) > PWM_BOUND)
  {
    controlSignal = constrain(controlSignal, -1, 1) * PWM_BOUND;
    error = constrain (error, -1, 1) * min(abs(error), PWM_BOUND/Kp);
    integrator = (controlSignal - Kp * error) / Ki;
  }

  if (error <= 0.0001)
  {
    controlSignal = 0;
  }

  Serial.println(error);
  controlSignal = abs(controlSignal);


 
  analogWrite(PWM_OUTPUT_PIN, controlSignal);
  storedIntegrator = integrator;
  storedTime = currentTime;
}
